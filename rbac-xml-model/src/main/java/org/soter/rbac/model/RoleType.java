//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0.3-b01-fcs 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2008.03.26 at 04:26:50 PM PDT 
//


package org.soter.rbac.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.security.Permissions;
import java.security.Permission;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlTransient;


/**
 * <p>Java class for roleType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="roleType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="role-name" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *         &lt;element name="sub-role" type="{http://geronimo.apache.org/xml/ns/rbac-xml}role-refType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="permission-id" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "roleType", propOrder = {
    "roleName",
    "subRole",
    "permissionId"
})
public class RoleType
    implements Serializable, Keyable<String>
{

    private final static long serialVersionUID = 12343L;
    @XmlElement(name = "role-name", required = true)
    protected String roleName;
    @XmlElement(name = "sub-role")
    protected List<RoleRefType> subRole;
    @XmlElement(name = "permission-id")
    protected List<String> permissionId;

    @XmlTransient
    private final Map<String, Set<Permission>> scopedPermissionSets = new HashMap<String, Set<Permission>>();
    @XmlTransient
    private final Map<String, Permissions> scopedPermissions = new HashMap<String, Permissions>();
    @XmlTransient
    private ScopeType scope;

    public RoleType() {
    }

    public RoleType(RoleType original, ScopeType owner) {
        roleName = original.roleName;
        subRole = original.subRole;
        permissionId = original.permissionId;

        scope = owner;
        scopedPermissionSets.putAll(original.scopedPermissionSets);
        scopedPermissions.putAll(original.scopedPermissions);
    }

    /**
     * Gets the value of the roleName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getRoleName() {
        return roleName;
    }

    public String getKey() {
        return getRoleName();
    }

    /**
     * Sets the value of the roleName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setRoleName(String value) {
        this.roleName = value;
    }

    /**
     * Gets the value of the subRole property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subRole property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubRole().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RoleRefType }
     * 
     * 
     */
    public List<RoleRefType> getSubRole() {
        if (subRole == null) {
            subRole = new ArrayList<RoleRefType>();
        }
        return this.subRole;
    }

    /**
     * Gets the value of the permissionId property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the permissionId property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPermissionId().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getPermissionId() {
        if (permissionId == null) {
            permissionId = new ArrayList<String>();
        }
        return this.permissionId;
    }

    public ScopeType getScope() {
        return scope;
    }

    public Map<String, Set<Permission>> getScopedPermissionSets() {
        return scopedPermissionSets;
    }

    public void startPermissions(ScopeType scope) {
        startPermissions(scope, permissionId);
        this.scope = scope;
    }

    private void startPermissions(ScopeType scope, List<String> permissionId) {
        if (permissionId != null) {
            for (String permissionid: permissionId) {
                PermissionType permissionType = scope.getPermissions().get(permissionid);
                if (permissionType == null) {
                    //should be prevented by schema constraints (not yet added to schema)
                    throw new NullPointerException("No permission for Id: " + permissionid);
                }
                ScopeType previous = null;
                for (ScopeType subScope = permissionType.getScope(); subScope != null && previous != scope; subScope = subScope.getParentScope()) {
                    String scopeName = subScope.getScopeName();
                    Set<Permission> permissions = getPermissionSetForScope(scopeName);
                    permissions.add(permissionType.getPermission());
                    previous = subScope;
                }
            }
        }
    }

    public void startSubRoles(ScopeType scope) {
        //roll up the subrole permissions by scope.
        startSubRoles(scope, this.subRole);

    }

    private void startSubRoles(ScopeType scope, List<RoleRefType> subRole) {
        Set<Permission> scopePermissions = getPermissionSetForScope(scope.getScopeName());
        if (subRole != null) {
            for (RoleRefType ref: subRole) {
                if (ref.getScopeName() == null) {
                    ref.setScopeName(scope.getScopeName());
                }
                RoleType role = scope.getRole(ref);
                Map<String, Set<Permission>> subScopedPermissionSets = role.getScopedPermissionSets();
                for (Map.Entry<String, Set<Permission>> entry: subScopedPermissionSets.entrySet()) {
                    Set<Permission> permissions = getPermissionSetForScope(entry.getKey());
                    permissions.addAll(entry.getValue());
                    if (permissions != scopePermissions) {
                        scopePermissions.addAll(entry.getValue());
                    }
                }
            }
        }
        //Turn the sets of permissions into Permissions objects
        for (Map.Entry<String, Set<Permission>> entry: scopedPermissionSets.entrySet()) {
            Set<Permission> permissionSet = entry.getValue();
            Permissions permissions = new Permissions();
            for (Permission permission: permissionSet) {
                permissions.add(permission);
            }
            permissions.setReadOnly();
            scopedPermissions.put(entry.getKey(), permissions);
        }
        //larger scopes have the same permissions as our particular scope in this role.
        Permissions permissions = scopedPermissions.get(scope.getScopeName());
        while ((scope = scope.getParentScope()) != null) {
            scopedPermissions.put(scope.getScopeName(), permissions);
        }
    }

    private Set<Permission> getPermissionSetForScope(String scopeName) {
        Set<Permission> permissions = scopedPermissionSets.get(scopeName);
        if (permissions == null) {
            permissions = new HashSet<Permission>();
            scopedPermissionSets.put(scopeName, permissions);
        }
        return permissions;
    }

    public boolean implies(Permission permission, String scope) {
        Permissions permissions = scopedPermissions.get(scope);
        if (permissions == null) {
            return false;
        }
        return permissions.implies(permission);
    }

    public void mergeModel(RoleType role) {
        for (RoleRefType subRole: role.getSubRole()) {
            //this is a wrong condition -- use scope && role name
            if (getSubRole().contains(subRole)) {
                throw new IllegalArgumentException("subRole: " + subRole + " is already a subrole of role " + getRoleName());
            }
            getSubRole().add(subRole);
        }
        for (String permissionId: role.getPermissionId()) {
            if (getPermissionId().contains(permissionId)) {
                throw new IllegalArgumentException(getRoleName() + " already has permission " + permissionId);
            }
            getPermissionId().add(permissionId);
        }
    }

    public void merge(RoleType role, ScopeType scope) {
//        if (role != this) {
//            for (RoleRefType subRole: role.getSubRole()) {
//                //TODO might throw an NPE if scope doesn't exist yet
//                if (scope.getRole(subRole) != null) {
//                    throw new IllegalArgumentException("subRole: " + subRole + " is already a subrole of role " + getRoleName());
//                }
//            }
//        }
        startPermissions(scope, role.permissionId);
        startSubRoles(scope, role.subRole);
    }

    public void mergeData(RoleType bit) {
        if (!getRoleName().equals(bit.getRoleName())) {
            throw new IllegalArgumentException("Mismatched merge: this is named " + getRoleName() + ", trying to merge: " + bit.getRoleName());
        }

        if (bit.subRole != null) {
            this.getSubRole().addAll(bit.subRole);
        }
        if (bit.permissionId != null) {
            this.getPermissionId().addAll(bit.permissionId);
        }
    }

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        RoleType roleType = (RoleType) o;

        if (roleName != null ? !roleName.equals(roleType.roleName) : roleType.roleName != null) return false;
        if (permissionId != null ? !new HashSet<String>(permissionId).equals(new HashSet<String>(roleType.getPermissionId())) : roleType.permissionId != null) return false;
        if (subRole != null ? !new HashSet<RoleRefType>(subRole).equals(new HashSet<RoleRefType>(roleType.getSubRole())) : roleType.subRole != null) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = (roleName != null ? roleName.hashCode() : 0);
        result = 31 * result + (subRole != null ? subRole.hashCode() : 0);
        result = 31 * result + (permissionId != null ? permissionId.hashCode() : 0);
        result = 31 * result + (scopedPermissionSets != null ? scopedPermissionSets.hashCode() : 0);
        result = 31 * result + (scopedPermissions != null ? scopedPermissions.hashCode() : 0);
        return result;
    }

}
